@inProceedings{
 title = {Robotics and Integrated Formal Methods: Necessity meets Opportunity},
 type = {inProceedings},
 year = {2018},
 identifiers = {[object Object]},
 pages = {10},
 volume = {026092},
 websites = {http://arxiv.org/abs/1805.11996},
 id = {0f42ac55-9f9d-31fe-8d79-9d2b5a07b57f},
 created = {2018-06-13T17:17:23.701Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-06-13T17:17:23.701Z},
 read = {false},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {Farrell2018},
 private_publication = {false},
 abstract = {Robotic systems are multi-dimensional entities, combining both hardware and software, that are heavily dependent on, and influenced by, interactions with the real world. They can be variously categorised as embedded, cyberphysical, real-time, hybrid, adaptive and even autonomous systems, with a typical robotic system being likely to contain all of these aspects. The techniques for developing and verifying each of these system varieties are often quite distinct. This, together with the sheer complexity of robotic systems, leads us to argue that diverse formal techniques must be integrated in order to develop, verify, and provide certification evidence for, robotic systems. Furthermore, we propose the fast evolving field of robotics as an ideal catalyst for the advancement of integrated formal methods research, helping to drive the field in new and exciting directions and shedding light on the development of large-scale, dynamic, complex systems.},
 bibtype = {inProceedings},
 author = {Farrell, Marie and Luckcuck, Matt and Fisher, Michael},
 booktitle = {Integrated Formal Methods}
}

@article{
 title = {Safety-Critical Java: Level 2 in Practice},
 type = {article},
 year = {2017},
 identifiers = {[object Object]},
 pages = {e3951},
 volume = {29},
 websites = {http://doi.wiley.com/10.1002/cpe.3951},
 month = {3},
 publisher = {Wiley Online Library},
 day = {25},
 id = {1d3858f5-28b8-3ea4-8080-abae0bd5f2b9},
 created = {2018-06-12T22:34:51.544Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-06-12T23:03:43.683Z},
 read = {false},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {Luckcuck2017},
 source_type = {article},
 folder_uuids = {71d1e442-4544-47e7-b039-78645e4f65c8},
 private_publication = {false},
 abstract = {Safety‐Critical Java (SCJ) is a profile of the Real‐Time Specification for Java that brings to the safety‐critical industry the possibility of using Java. SCJ defines three compliance levels: Level 0, Level 1 and Level 2. The SCJ specification is clear on what constitutes a Level 2 application in terms of its use of the defined API but not the occasions on which it should be used. This paper broadly classifies the features that are only available at Level 2 into three groups: nested mission sequencers, managed threads and global scheduling across multiple processors. We explore the first two groups to elicit programming requirements that they support. We identify several areas where the SCJ specification needs modifications to support these requirements fully; these include the following: support for terminating managed threads, the ability to set a deadline on the transition between missions and augmentation of the mission sequencer concept to support composibility of timing constraints. We also propose simplifications to the termination protocol of missions and their mission sequencers. To illustrate the benefit of our changes, we present excerpts from a formal model of SCJ Level 2 written in Circus, a state‐rich process algebra for refinement.},
 bibtype = {article},
 author = {Luckcuck, Matt and Wellings, Andy and Cavalcanti, Ana},
 journal = {Concurrency and Computation: Practice and Experience},
 number = {6}
}

@inProceedings{
 title = {A Formal Model of the Safety-Critical Java Level 2 Paradigm},
 type = {inProceedings},
 year = {2016},
 identifiers = {[object Object]},
 pages = {226-241},
 volume = {9681},
 issue = {vol 9681},
 websites = {http://link.springer.com/10.1007/978-3-319-33693-0_15},
 id = {3e84c403-d33f-3f5b-82a3-fe341c885de7},
 created = {2018-01-17T14:22:23.359Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-06-12T22:35:56.368Z},
 read = {false},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {Luckcuck2016},
 folder_uuids = {71d1e442-4544-47e7-b039-78645e4f65c8},
 private_publication = {false},
 abstract = {Safety-Critical Java (SCJ) introduces a new programming paradigm for applications that must be certified. The SCJ specification (JSR 302) is an Open Group Standard, but it does not include verification techniques. Previous work has addressed verification for SCJ Level 1 programs. We support the much more complex SCJ Level 2 programs, which allows the programming of highly concurrent multiprocessor applications with Java threads, and wait and notify mechanisms. We present a formal model of SCJ Level 2 that captures the state and behaviour of both SCJ programs and the SCJ API. This is the first formal semantics of the SCJ Level 2 paradigm and is an essential ingredient in the development of refinement-based reasoning techniques for SCJ Level 2 programs. We show how our models can be used to prove properties of the SCJ API and applications.},
 bibtype = {inProceedings},
 author = {Luckcuck, Matt and Cavalcanti, Ana and Wellings, Andy},
 booktitle = {Integrated Formal Methods 2016}
}

@inProceedings{
 title = {A Formal Model for the SCJ Level 2 Paradigm},
 type = {inProceedings},
 year = {2015},
 identifiers = {[object Object]},
 websites = {http://fm2015.ifi.uio.no/wp-content/uploads/2015/06/ds-fm15-proceedings.pdf,https://www.cs.york.ac.uk/circus/publications/papers/Luckcuck2015.pdf},
 city = {Oslo},
 id = {3a9de2e1-58ce-37da-b523-cd69af1453d0},
 created = {2018-01-17T14:27:22.732Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-06-12T22:35:34.466Z},
 read = {false},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {Luckcuck2015},
 language = {en},
 country = {NO},
 folder_uuids = {71d1e442-4544-47e7-b039-78645e4f65c8},
 private_publication = {false},
 bibtype = {inProceedings},
 author = {Luckcuck, Matt},
 booktitle = {Doctoral Symposium of Formal Methods 2015}
}

@article{
 title = {Safety-critical Java level 2: Motivations, example applications and issues},
 type = {article},
 year = {2013},
 identifiers = {[object Object]},
 keywords = {Application programming interfaces (API);Embedded},
 pages = {48-57},
 websites = {http://dx.doi.org/10.1145/2512989.2512991},
 id = {55828269-d909-3309-b3e7-8cb139affeed},
 created = {2017-11-24T12:12:34.585Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-06-12T22:35:34.665Z},
 read = {true},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {Wellings2013},
 folder_uuids = {93703058-091c-4fe3-9b1a-f5b9516d8319,71d1e442-4544-47e7-b039-78645e4f65c8},
 private_publication = {false},
 abstract = {Safety Critical Java defines three compliance levels: Level 0, Level 1 and Level 2. Applications that can be scheduled using cyclic-executive techniques can be implemented at Level 0. Applications that can use simple analysable fixed-priority scheduling can be implemented at Level 1. However, Level 2 also targets fixed-priority scheduling, so this cannot be used to decide whether to use Level 1 or Level 2. The SCJ specification is clear on what constitutes a Level 2 application in terms of its use of the defined API, but not the occasions on which it should be used. Hence, it is not clear what application requirements dictate a Level 2 solution. This paper broadly classifies the features that exist only at Level 2 into three groups: support for nested mission sequencers, support for managed threads, including the use of the Object.wait, Object.notify, HighResolutionTime. waitForObject and Services.delay methods, and support for global scheduling across multiple processors. In this paper we explore the first two groups to derive possible programming requirements that each group of features support. We identify several areas where the specification needs modifications in order to support fully these derived requirements. These include support for terminating managed threads, the ability to set a deadline on the transition between missions, and augmentation of the mission sequencer concept to support composibility of timing constraints. &amp;copy; 2013 ACM.},
 bibtype = {article},
 author = {Wellings, Andy and Luckcuck, Matt and Cavalcanti, Ana},
 journal = {ACM International Conference Proceeding Series}
}

@article{
 title = {Formal Specification and Verification of Robotic Systems: A Survey},
 type = {article},
 id = {950fe9af-a6ba-339f-b9c6-d0e29cc3de59},
 created = {2018-04-11T15:07:49.918Z},
 file_attached = {false},
 profile_id = {184d7076-d431-3c63-8270-c609802786ab},
 last_modified = {2018-05-27T17:53:16.559Z},
 read = {false},
 starred = {false},
 authored = {true},
 confirmed = {true},
 hidden = {false},
 citation_key = {RobotSpecSurvery},
 folder_uuids = {f8083d97-e306-448f-bb81-d1714a835314},
 private_publication = {false},
 bibtype = {article},
 author = {Luckcuck, Matt and Farrell, Marie and Dennis, Louise and Dixon, Clare and Fisher, Michael}
}

